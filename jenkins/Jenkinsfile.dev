pipeline {
    agent none
    
    environment {
        // Hardcoded Configuration
        BUILD_TIMEOUT = "200"
        HOST = "x86_64-Linux"
        SBUILD_URL = "https://example.com/path/to/SBUILD.yml"
        PKG_FAMILY = "example-package"
        CI_INFRA = "github"
        KEEP_LOGS = true
        REBUILD = true
        
        // System Configuration
        SYSTMP = "${env.WORKSPACE}/tmp"
        GHA_MODE = "JENKINS"
        USER_AGENT = "Jenkins-CI-Package-Builder/1.0"
        
        // Credentials
        RO_GHTOKEN = credentials('ro-ghtoken')
        RO_GLTOKEN = credentials('ro-gltoken')
        MINISIGN_KEY = credentials('minisign-key')
    }

    stages {
        stage('Pre-Setup & Validation') {
            agent { label 'master' }
            steps {
                script {
                    // Validate timeout value
                    if (!env.BUILD_TIMEOUT.isInteger()) {
                        error("BUILD_TIMEOUT must be an integer value")
                    }
                    
                    // Create temporary directory
                    sh '''
                    mkdir -p ${SYSTMP}
                    mkdir -p ${SYSTMP}/_POD_BRIDGE
                    '''
                    
                    // Validate SBUILD_URL
                    if (env.SBUILD_URL.isEmpty()) {
                        error("SBUILD_URL must be configured")
                    }
                    
                    // Validate PKG_FAMILY
                    if (env.PKG_FAMILY.isEmpty()) {
                        error("PKG_FAMILY must be configured")
                    }
                    
                    // Normalize package family name
                    PKG_FAMILY_LOCAL = env.PKG_FAMILY.toLowerCase().replaceAll("\\s", "")
                    
                    // Generate runner matrix
                    RUNNER_MATRIX = generateRunnerMatrix(env.HOST, env.CI_INFRA)
                }
            }
        }

        stage('Build Packages') {
            matrix {
                axes {
                    axis {
                        name 'PACKAGE'
                        values readJSON(text: env.RUNNER_MATRIX).collect { it.host }
                    }
                }
                agent { 
                    label "${PACKAGE.contains('aarch64') ? 'arm64-node' : 
                          PACKAGE.contains('riscv64') ? 'riscv64-node' : 
                          'amd64-node'}" 
                }
                stages {
                    stage('Setup Build Environment') {
                        steps {
                            script {
                                // Find the matrix entry for this host
                                def matrixEntry = readJSON(text: env.RUNNER_MATRIX).find { it.host == PACKAGE }
                                env.HOST_TRIPLET = matrixEntry.host
                                env.RUNNER = matrixEntry.runner
                                
                                // Determine if cross-compiling
                                def hostArch = sh(script: 'uname -m', returnStdout: true).trim()
                                if (HOST_TRIPLET != "${hostArch}-Linux") {
                                    env.CROSS_COMPILING = "YES"
                                    env.ON_QEMU = "YES"
                                } else {
                                    env.CROSS_COMPILING = "NO"
                                    env.ON_QEMU = "NO"
                                }
                                
                                // Setup platform-specific variables
                                if (HOST_TRIPLET.contains("aarch64")) {
                                    env.DOCKER_PLATFORM = "linux/arm64"
                                } else if (HOST_TRIPLET.contains("loongarch64")) {
                                    env.DOCKER_PLATFORM = "linux/loong64"
                                } else if (HOST_TRIPLET.contains("riscv64")) {
                                    env.DOCKER_PLATFORM = "linux/riscv64"
                                } else if (HOST_TRIPLET.contains("x86_64")) {
                                    env.DOCKER_PLATFORM = "linux/amd64"
                                }
                                
                                // Install required dependencies
                                sh '''
                                sudo apt-get update -y
                                sudo apt-get install -y \
                                    bc coreutils curl dos2unix fdupes jq moreutils wget \
                                    apt-transport-https apt-utils ca-certificates gnupg2 \
                                    p7zip-full rename rsync software-properties-common \
                                    texinfo tmux util-linux
                                
                                # Install yq for SBUILD parsing
                                sudo curl -qfsSL "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_${HOST_TRIPLET.startsWith('aarch64') ? 'arm64' : 'amd64'}" \
                                    -o /usr/local/bin/yq && \
                                    sudo chmod +x /usr/local/bin/yq
                                '''
                                
                                // Setup Minisign
                                sh '''
                                mkdir -p ${HOME}/.minisign
                                echo "${MINISIGN_KEY}" > ${HOME}/.minisign/pkgforge.key
                                chmod 600 ${HOME}/.minisign/pkgforge.key
                                '''
                            }
                        }
                    }

                    stage('Process SBUILD') {
                        steps {
                            script {
                                // Download and validate SBUILD file
                                sh '''
                                curl -w "(SBUILD) <== %{url}\\n" -fL "${SBUILD_URL}" -o "${SYSTMP}/SBUILD_INPUT"
                                if [ ! -s "${SYSTMP}/SBUILD_INPUT" ] || [ $(stat -c%s "${SYSTMP}/SBUILD_INPUT") -le 10 ]; then
                                    echo "[âœ—] FATAL: Failed to fetch ${SBUILD_URL}"
                                    exit 1
                                fi
                                '''
                                
                                // Check host support in SBUILD
                                def hostSupported = sh(
                                    script: '''
                                    yq e '.x_exec.host[]' "${SYSTMP}/SBUILD_INPUT" | \
                                    grep -v '^#' | \
                                    grep -qi "${HOST_TRIPLET,,}" && echo "YES" || echo "NO"
                                    ''',
                                    returnStdout: true
                                ).trim()
                                
                                if (hostSupported == "NO") {
                                    error("SBUILD does not support ${HOST_TRIPLET} architecture")
                                }
                                
                                // Determine build system
                                def buildSystem = sh(
                                    script: '''
                                    yq '.x_exec.bsys' "${SYSTMP}/SBUILD_INPUT" | \
                                    grep -v '^#' | \
                                    grep -qi "docker://" && echo "DOCKER" || \
                                    (grep -qi "host://" && echo "HOST" || echo "UNKNOWN")
                                    ''',
                                    returnStdout: true
                                ).trim()
                                
                                if (buildSystem == "UNKNOWN") {
                                    error("Unknown build system specified in SBUILD")
                                }
                                
                                env.BUILD_SYSTEM = buildSystem
                            }
                        }
                    }

                    stage('Execute Build') {
                        steps {
                            script {
                                // Prepare build environment
                                sh '''
                                mkdir -p "${SYSTMP}/build_artifacts"
                                curl -qfsSL "https://raw.githubusercontent.com/pkgforge/bincache/main/scripts/runner/builder.sh" \
                                    -o "${SYSTMP}/BUILDER.sh"
                                chmod +x "${SYSTMP}/BUILDER.sh"
                                '''
                                
                                // Execute build based on system
                                if (env.BUILD_SYSTEM == "DOCKER") {
                                    sh '''
                                    docker run --rm \
                                        --platform "${DOCKER_PLATFORM}" \
                                        -v "${SYSTMP}:/tmp" \
                                        -v "${HOME}/.minisign:/root/.minisign" \
                                        -e "RO_GHTOKEN=${RO_GHTOKEN}" \
                                        -e "RO_GLTOKEN=${RO_GLTOKEN}" \
                                        -e "MINISIGN_KEY=${MINISIGN_KEY}" \
                                        -e "KEEP_LOGS=${KEEP_LOGS}" \
                                        -e "PKG_FAMILY_LOCAL=${PKG_FAMILY_LOCAL}" \
                                        -e "REBUILD=${REBUILD}" \
                                        -e "HOST_TRIPLET=${HOST_TRIPLET}" \
                                        ubuntu:latest \
                                        /bin/bash -c "/tmp/BUILDER.sh ${SBUILD_URL}"
                                    '''
                                } else {
                                    // Host build
                                    sh '''
                                    export RO_GHTOKEN="${RO_GHTOKEN}"
                                    export RO_GLTOKEN="${RO_GLTOKEN}"
                                    export MINISIGN_KEY="${MINISIGN_KEY}"
                                    export KEEP_LOGS="${KEEP_LOGS}"
                                    export PKG_FAMILY_LOCAL="${PKG_FAMILY_LOCAL}"
                                    export REBUILD="${REBUILD}"
                                    export HOST_TRIPLET="${HOST_TRIPLET}"
                                    export BUILD_SYSTEM="${BUILD_SYSTEM}"
                                    
                                    "${SYSTMP}/BUILDER.sh" "${SBUILD_URL}"
                                    '''
                                }
                                
                                // Archive artifacts
                                sh '''
                                if [ -f "${SYSTMP}/BUILD_ARTIFACTS.zstd" ]; then
                                    mkdir -p "${WORKSPACE}/artifacts/${HOST_TRIPLET}"
                                    cp "${SYSTMP}/BUILD_ARTIFACTS.zstd" "${WORKSPACE}/artifacts/${HOST_TRIPLET}/"
                                    cp "${SYSTMP}/BUILD.log" "${WORKSPACE}/artifacts/${HOST_TRIPLET}/"
                                fi
                                '''
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                // Archive artifacts if they exist
                if (fileExists("${WORKSPACE}/artifacts")) {
                    archiveArtifacts artifacts: "artifacts/**", allowEmptyArchive: true
                }
                
                // Clean up if not keeping logs
                if (!env.KEEP_LOGS.toBoolean()) {
                    sh "rm -rf ${SYSTMP}"
                }
            }
        }
        
        success {
            echo "Build completed successfully for all architectures"
        }
        
        failure {
            echo "Build failed for one or more architectures"
        }
    }
}

// Helper function to generate runner matrix
def generateRunnerMatrix(host, ciInfra) {
    def matrix = []
    
    if (host == "ALL") {
        matrix = [
            [host: "aarch64-Linux", runner: "ubuntu-24.04-arm"],
            [host: "x86_64-Linux", runner: "ubuntu-latest"]
        ]
    } else {
        matrix = [[host: host, runner: ciInfra == "circle-ci" ? "${host.split('-')[0]}-linux-circle" : "ubuntu-latest"]]
    }
    
    return writeJSON returnText: true, json: matrix
}